링크 : https://youtu.be/Tb8dsxjhNLQ?si=3AzQPpnqdt1Yh5F4


# *가비지 컬렉션
- c/c++에서 힙에 할당한 객체에 대한 해제 코드 필수
	- 해제 코드 누락
		- 메모리 누수
		- 프로그램 오류
- c#에서 힙에 할당한 객체는 *CLR이 자동으로 수거*
	- CLR은 더 이상 사용하지 않는 객체는 쓰레기로 판단
	- 이 메모리 쓰레기를 수거하는 것이 *가비지 컬렉션*


# *CLR이 객체를 할당하는 과정*
- CLR은 어플리케이션을 위한 메모리 공간을 통쨰로 확보
- 하나의 관리되는 힙을 마련
- 객체가 할당될 때마다 관리되는 힙에 순차적으로 적재
![[Pasted image 20240221004702.png]]


# *쓰레기가 생길 때*
![[Pasted image 20240221004827.png]]


# *가비지 컬렉션 과정 (1/3)*
- GC 루트
	- 루트는 힙에 있는 객체를 붙드는 참조
	- 루트는 a처럼 스택 또는 힙(예:정적 필드)에 생성
	- .NET 어플리케이션 실행시, JUT 컴파일러는 *루트 목록 생성*
	- CLR은 이 루트 목록을 관리하며 상태 갱신
	- 루트 목록은 가비지 컬렉터가 참조하는 중요 자료
![[Pasted image 20240221005127.png]]
![[Pasted image 20240221005144.png]]


# *가비지 컬렉션 과정 (2/3)*
- 가비지 컬렉터는 *초기에 모든 객체가 쓰레기라고 가정*
	  (즉, 루트 목록 내의 어떤 루트도 메모리를 가리키지 않는다고 가정)
- 루트 목록을 순회하면서 각 루트가 참조하는 힙ㅇ 객체와의 관계 조사
	- *어떤 힙과도 관계가 없는 루트는 쓰레기
	- 다른 힙 객체를 *참조하는 힙 객체는 쓰레기가 아님*
- 쓰레기 객체가 차지하고 있던 메모리는 이제 *"비어있는 공간"*
![[Pasted image 20240221005510.png]]


# *가비지 컬렉션 과정 (3/3)*
- 루트 목록에 대한 조사 후, 가비지 컬렉터는 힙을 순회하며 쓰레기가 차지하고 있던 "비어있는 공간"으로 쓰레기 인접 객체들을 이동 정리
![[Pasted image 20240221005648.png]]


# *세대별 가비지 컬렉션 (1/2)*
- CLR은 메모리를 *0,1,2의 3개 세대로 분리*
- 객체의 나이가 어릴수록 메모리에서 빨리 사라지고 나이가 많을 수록 메모리에서 오랫동안 살아남는다고 간주 + *나이 : 가비지 컬렉션을 겪은 횟수*
- 0세대 : 가비지 컬렉션을 한번도 겪지 않은  "갓 생성된 객체"
- 2세대 : 최소 2회 이상 가비지 컬렉션을 경험한 객체
- 1세대 : 0세대와 2세대 사이의 과도기에 있는 객체


# *세대별 가비지 컬렉션 (2/2)*
![[Pasted image 20240221010211.png]]
